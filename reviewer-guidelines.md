---
title: Reviewer Guidelines
date: 03-14-2015
layout: blank
---

# Reviewer Guidelines

## Our Review Philosophy
<figure>
	<img src="../images/reviewer-sm.png" width="150px" style="float: left; margin-right: 15px; margin-bottom: 15px;" />
</figure>
Reviewing for the _Programming Historian_ is a great way to learn new technical skills (at any level) and engage with the digital humanities community at the same time. We go out of our way to make sure our reviewers get ample credit and recognition for their work. Because reviewers directly contribute to significantly improving lessons, you can take pride in how your work helps thousands of users.

## Collaborative, Not Judgmental
Our peer review process is a bit different from what might be considered the "traditional" peer review process. We do not solicit reviews to judge whether a tutorial is "good enough" to be published. Rather, we consider the review process an integral component of a collaborative, productive, and sustainable effort for scholars to create useful technical resources for each other. Once a tutorial slips into our editorial workflow, our goal is to do everything we can to make sure the tutorial becomes as useful as possible and published in a reasonable amount of time.

## Constructive Criticism for Colleagues
To review a tutorial is not simply to assess its merits and flaws (though it is important to do these as well), or judge whether it's appropriate for _Programming Historian_, but to help improve the tutorial as an outside reader. We ask that reviewers comment on tutorials as they would on a paper or similar for a colleague--to provide fair and constructive criticism (and of course praise) that will improve the tutorial for a wide range of readers. We don't send anything out for review that isn't within a reasonable distance of publishable quality. A few extra perspectives and suggestions (beyond those of the editor) greatly improve lessons and make them of great (and unique) value to the community.

## Transparency
We highly value transparency in our lesson production and review process. Our review process happens on Github, where our lessons are hosted. Namely, we use Github's commenting and [issue tracking](https://en.wikipedia.org/wiki/Issue_tracking_system) capabilities to keep track of suggestions and how they are handled and discussed by the authors and reviewers. This helps avoid important conversations becoming lost in archived email threads. Future tutorial users can easily rekindle a old conversation that has become newly relevant.

Therefore, your work as a reviewer--and your identity--will be fully visible to the author. Comments should engage with the author and lesson directly, rather than the review editor. If at any point you are unsure of your role or what to do next, feel free to post a question to clarify and an editor will respond as soon as they can. Youâ€™ll understand that sometimes it will take the editor a few days to respond, but we hope the improvements to your lesson will be worth the wait.

In keeping with the ideas of public scholarship and open peer review, we generally encourage discussions to stay on GitHub as outlined in our editorial workflow. However, we also want everyone to feel comfortable and we recognise that in some cases a private word may be more appropriate. If you feel the need to discuss a matter related to a tutorial or a matter related to the review, please feel free to email the assigned editor directly, or to contact one of our dedicated ombudspersons, Miriam Posner or Ian Milligan.

Unless you instruct us otherwise, your name will be indicated as a reviewer on the lesson's page at the _Programming Historian_ when it is officially published; you'll also be listed on our contributors page. These are, of course, insufficient tokens of appreciation, but we want to emphasize that the _Programming Historian_ is the work of volunteers and give credit where credit is due.

## What To Comment On
The informal style of _Programming Historian_ lessons can make the lessons appear deceptively simple to write. In fact, writing a good tutorial is every bit as demanding, if not more so, than any other kind of scholarly writing. Below are a few common questions to keep in mind as you review a lesson. Some will be more relevant than others, depending on the topic, intended audience, and the difficulty of the tutorial. Needless to say, this is neither a restrictive or comprehensive list; we do not ask that reviewers respond to each and every question, but hopefully they can provide some general guidance.

### Audience
If you haven't dabbled much at the _Programming Historian_ already, you'll see that there is no standard audience across all of the lessons. Some are for complete beginners, others are for those considerably more comfortable with technical concepts and methods, and yet others are directed toward experienced digital historians looking to solve difficult technical challenges. We welcome such variety!

While we like each of our lessons to take the unique voice of its author, we also want each individual lesson to remain clear and consistent in its tone. More specifically, we want the technical explanations (and difficulty) to remain as constant as possible throughout the lesson. As a reviewer, it is quite useful to note any sections of a tutorial directed at more technically advanced users that seem to over-explain relatively simple concepts; the converse is true, too: we want to avoid sections of tutorials aimed at beginners that don't adequately explain fundamental concepts central to the tutorial. Some questions to keep in mind:

- Does the author address a consistent model reader throughout the lesson? 
- Are some concepts or steps over-explained while other are under-explained?
- Does the audience seem to match at least vaguely with other _Programming Historian_ lessons? How is it new?

### Getting Ready
- What software / programming languages are required?
- What prerequisite skills are needed?
- What familiarity or experience is needed?
- What data are needed? Is the dataset readily available?

### Skimmability
- Are there clearly defined learning objectives or sets of skills to be learned listed near the top of the lesson?
- Are there useful secondary skills to be gained / practiced from the lesson?
- Do screenshots and other diagrams illustrate crucial steps / points of the lesson?
- Do sections and section headings provide clear signage to the reader?

### Payoff
- Does the tutorial suggest why the explained tools or techniques are useful in a general way?
- Does the tutorial suggest how a reader could apply the concepts (if not concrete steps) of the lesson to their own work?

### Workflow
- Should a long lesson be divided into smaller lessons?
- Are there logical stopping points throughout the lesson?
- If datasets are required, are they available to download at various points throughout the lesson (or different versions of them as the tutorial may require)?

### Integrating with the _Programming Historian_
- Does the lesson build upon an existing lesson and explain how? 
- Does the lesson tie into existing lessons and have appropriate links?


## How to submit your review
We manage all of our peer review comments through GitHub. When a new lesson is ready for review, the author (or editor) will make a pull request (a request to pull the new lesson into the _Programming Historian_ repository.) GitHub allows anyone to make comments on a pull request--exactly like posting on a message board or social media website. You will need to sign up for a free GitHub account to post your review. 

The editor who contacted you about the review should have sent you the URL that corresponds with the pull request (ie the page where you will leave your comment). You can also find the issue on the [_Programming Historian's_ pull request page](https://github.com/programminghistorian/jekyll/pulls); the link to the pull request will contain the lesson title, so it will be obvious what to click on. If you cannot find the pull request for the lesson you're looking for, please contact the editor. Once you've found the pull request for the lesson you're reviewing, click on it (be sure you're logged into GitHub), and add your review as a comment at the bottom of the page. Then, you're done, and you have our eternal gratitude.
